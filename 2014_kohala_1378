#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    autoControl,    sensorNone)
#pragma config(Sensor, dgtl11, drive,          sensorQuadEncoder)
#pragma config(Sensor, I2C_2,  liftR,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           liftLB,        tmotorVex393, openLoop)
#pragma config(Motor,  port2,           liftLT,        tmotorVex393, openLoop)
#pragma config(Motor,  port3,           driveLBack,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           driveLFront,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           intakeL,       tmotorVex393, openLoop)
#pragma config(Motor,  port6,           intakeR,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           driveRFront,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           driveRBack,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           liftRT,        tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port10,          liftRB,        tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//          2014-2015 VEX Skyrise
//      Description: 4-motor WD, 4-motor eight-bar lift, 2-motor intake
//
///////////////////////////////////////////////////////////////////////////////////////////////////////



//---------------------------------------PID Below--------------------------------------------------//
int armHeight = 0;

task ArmControl()
{
	int error = 0;
	int speed = 0;
	float integral = 0;
	float derivative = 0;
	int previousError = 0;
	int encoderValue = 0;

	const int ACCEPTABLE_ERROR = 0;
	const int INTEGRAL_UPPER_BOUND = 20;

	int P_VALUE = 0; //For debugging.  Calculates constant*value to view amount of motor adjustment for each of the 3 parts.
	int I_VALUE = 0;
	int D_VALUE = 0;

	float KP = 0.6; //0.4
	float KI = 0;
	float KD = 0;

	//SensorValue(lift) = 0;
	while (1) //Loop continously to make sure task doesn't stop
	{
		//-------find the error-----------------------------
		encoderValue = SensorValue(liftR);
		error = armHeight - encoderValue;  //Remember, error can be + or -
		if( abs(error) < ACCEPTABLE_ERROR )
		{
			error = 0;
		}
		//--------get the integral--------------------------
		integral = integral + error;
		if ( error == 0 )
		{
			integral = 0;
		}
		if ( (integral * KI) > INTEGRAL_UPPER_BOUND)
		{
			integral = 0;
		}


		//---------get derivitive and previous error--------
		derivative = error - previousError;
		previousError = error;

		//---------Factor in the constants (for debugging)--
		P_VALUE = KP * error;
		I_VALUE = KI * integral;
		D_VALUE = KD * derivative;

		//---------set speed using PID and K constants------
		speed = P_VALUE + I_VALUE + D_VALUE;

		//---------motor control goes here------------------
		if( vexRT( Btn5U ) )
		{
			motor[liftLT] = 127;
			motor[liftLB] = 127;
			motor[liftRT] = 127;
			motor[liftRB] = 127;

			ArmHeight = SensorValue(liftR) + 8;
		}
		else if( vexRT( Btn5D ) )
		{
			motor[liftLT] = -127;
			motor[liftLB] = -127;
			motor[liftRT] = -127;
			motor[liftRB] = -127;

			ArmHeight = SensorValue(liftR);
		}


		else //4if ( !(SensorValue(liftEncoder) < 10 ) && !(armHeight < 10 ) )
		{
			motor[liftLT] = speed;
			motor[liftLB] = speed;
			motor[liftRT] = speed;
			motor[liftRB] = speed;
		}



		//wait1Msec(5);

	}
}
//---------------------------------Functions---------------------------------------//
void Move( int howFast, int howFar )
{

	SensorValue[drive] = 0;
	while( abs(SensorValue[drive]) < howFar )
	{

		motor[driveLFront] = howFast;
		motor[driveLBack] = howFast;

		motor[driveRBack] = howFast;
		motor[driveRFront] = howFast;
	}
	motor[driveLFront] = 0;
	motor[driveLBack] = 0;

	motor[driveRBack] = 0;
	motor[driveRFront] = 0;

}

void PointTurn( int leftDrive, int rightDrive, int turnDegree )
{
	SensorValue[drive] = 0;
	while( abs(SensorValue[drive]) < abs(turnDegree) )
	{
		motor[driveRBack] = rightDrive;
		motor[driveRFront] = rightDrive;
		motor[driveLBack] = leftDrive;
		motor[driveLFront] = leftDrive;
	}
	motor[driveRBack] = 0;
	motor[driveRFront] = 0;
	motor[driveLBack] = 0;
	motor[driveLFront] = 0;


}

void LiftArm( int armSpeed, int howHeigh )
{
	while( abs(SensorValue(liftR) ) < howHeigh )
	{
		motor[liftLT] = armSpeed;
		motor[liftLB] = armSpeed;
		motor[liftRT] = armSpeed;
		motor[liftRB] = armSpeed;
	}

	motor[liftLT] = 0;
	motor[liftLB] = 0;
	motor[liftRT] = 0;
	motor[liftRB] = 0;
}

void Intake( int intakeSpeed )
{
	motor[intakeL] = intakeSpeed;
	motor[intakeR] = intakeSpeed;
}
/////////////------------------------------------------Autonomous--------------------------------/////////////////////


void AutoRedZero()
{
	SensorValue(liftR) = 0;
	SensorValue(drive) = 0;

	motor[intakeL] = -127;
	motor[intakeR] = -127;

	PointTurn( 100, 127, 700 );
	wait1Msec(700);
	PointTurn( -100, -127, 700 );
	motor[intakeL] = 0;
	motor[intakeR] = 0;
	//wait1Msec(700);
	PointTurn(80, -80, 1000 );
	wait1Msec(500);


	armHeight = 600;
	wait1Msec(300);
	Move( 127, 450);
	motor[intakeL] = 127;
	motor[intakeR] = 127;

}





/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	/*int mid = 1;
	int hang = 1;
	bStopTasksBetweenModes = true;

	bLCDBacklight = true;
	sLCDButtons retrievedButton = noButton;

	/* INFORMATION TO BE DETERMINED 


	displayLCDCenteredString(0,"Loading..."); // random loading screen becase we can
	clearLCDLine(1);
	wait1Msec(100);

	displayLCDCenteredString(0,"Alliance Color?");
	displayLCDAlignedString(1,left,"Blue");
	displayLCDAlignedString(1,right,"Red");
	retrievedButton = enterLCDButton(true,false,true);
	switch(retrievedButton)
	{
	case leftButton:
		allianceColor = blue;
		displayLCDCenteredString(0,"Selected:");
		displayLCDCenteredString(1,"BLUE");
		break;
	case rightButton:
		allianceColor = red;
		displayLCDCenteredString(0,"Selected:");
		displayLCDCenteredString(1,"RED");
		break;
	default:
		allianceColor = nullColor;
		displayLCDCenteredString(0,"Error Selecting");
		displayLCDCenteredString(1,"Terminating"); //Your code would "terminate" the selection process, or you could say "defaulting" if you have a default autonomous
		break;
	}
	wait10Msec(50);
	clearLCDLine(0);
	clearLCDLine(1);
	retrievedButton = noButton;

	if(allianceColor != nullColor)
	{
		displayLCDCenteredString(0,"Alliance Pos?");
		char leftArrow = 200;
		char rightArrow = 199;
		string leftText; sprintf(leftText, "Mid %c ", leftArrow);
		string rightText; sprintf(rightText, "Hang %c", rightArrow);
		displayLCDAlignedString(1,mid,leftText);
		displayLCDAlignedString(1,hang,rightText);
		retrievedButton = enterLCDButton(true,false,true);
		switch(retrievedButton)
		{
		case leftButton:
			alliancePosition = mid;
			displayLCDCenteredString(0,"Selected:");
			displayLCDCenteredString(1,"MID");
			break;
		case rightButton:
			alliancePosition = hang;
			displayLCDCenteredString(0,"Selected:");
			displayLCDCenteredString(1,"HANG");
			break;
		default:
			alliancePosition = nullPosition;
			displayLCDCenteredString(0,"Error Selecting");
			displayLCDCenteredString(1,"Terminating");
			break;
		}
		wait10Msec(50);
		clearLCDLine(0);
		clearLCDLine(1);
		retrievedButton = noButton;

		if(alliancePosition != nullPosition)
		{
			bool quit = false;
			int selectedRoutine = (numberOfRoutines/2);

			displayLCDCenteredString(0,"Select Routine");
			while(!quit)
			{
				switch(selectedRoutine) {
				case 1:
					displayLCDCenteredString(1,"<    R1    >");
					break;
				case 2:
					displayLCDCenteredString(1,"<    R2    >");
					break;
				case 3:
					displayLCDCenteredString(1,"<    R3    >");
					break;
				case 4:
					displayLCDCenteredString(1,"<    R4    >");
					break;
				case 5:
					displayLCDCenteredString(1,"<    R5    >");
					break;
				default:
					displayLCDCenteredString(1,"ERROR");
					break;
				}
				retrievedButton = enterLCDButton(true,true,true);
				switch(retrievedButton) {
				case leftButton:
					if(selectedRoutine <= 1) selectedRoutine = numberOfRoutines;
					else selectedRoutine--;
					break;
				case rightButton:
					if(selectedRoutine >= numberOfRoutines) selectedRoutine = 1;
					else selectedRoutine++;
					break;
				case centerButton:
					routineToRun = selectedRoutine;
					quit = true;
					break;
				}
			}
			displayLCDCenteredString(0,"Selected:");
			switch(routineToRun)
			{
			case 1:
				displayLCDCenteredString(1,"R1");
				break;
			case 2:
				displayLCDCenteredString(1,"R2");
				break;
			case 3:
				displayLCDCenteredString(1,"R3");
				break;
			case 4:
				displayLCDCenteredString(1,"R4");
				break;
			case 5:
				displayLCDCenteredString(1,"R5");
				break;
			default:
				displayLCDCenteredString(1,"ERROR");
				break;
			}
			wait1Msec(500);

			displayLCDCenteredString(0,"Selections:");
			string selections; sprintf(selections, "%i , %i , R%i", allianceColor, alliancePosition, selectedRoutine);
			displayLCDCenteredString(1,selections);
			wait1Msec(1000);
		}
	}

	SensorValue(liftR) = 0;
}*/

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	StartTask(ArmControl);
	//ProgrammingSkills();

}


void ProgrammingSkills()
{
	Intake( 127 );
	Move( 127, x );
	wait1Msec( 200 );
	Move( 127, x );
	wait1Msec( 800 );
	Move( -127, x );
	Intake( 0 );
	PointTurn( -127, 127, x );
	Move( 127, x );
	wait1Msec(2000);
	Move( 127, x );
	armHeight = x;
	Move( 80, x );
	Intake( -127 );
	wait1Msec(3000);
	Move( -120, x );
	armHeight = 0;
	PointTurn( -127, 127, x );
	Move( 127, x );
	wait1Msec( 2000 );
	Move( 127, x );
	PointTurn( -127, 127, x );
	Move( 127, x );
	Move( -127, x );
	PointTurn( 127, -127, x );
	Move( 127, x );
	PointTurn( -127, 127, x );
	Move( 127, x );
	Move( -127, x );
	PointTurn( 127, -127, x );
	Move( 127, x );
	PointTurn( -127, 127, x );
	Move( 127, x );
	Move( -127, x );
	PointTurn( 127, -127, x );
	Move( 127, x );
	wait1Msec( 2000);

	Move( 127, x );
	wait1Msec(1000);
	Intake( 127 );
	Move( 127, x );
	wait1Msec(200);
	Move( 127, x );
	wait1Msec(800);
	Move (-127, x );
	Intake(0);
	PointTurn( -127, 127, x );
	Move( 127, x );
	wait1Msec(2000);
	Move( 127, x );
	armHeight = x;
	Move( 100, x );
	Intake(-127);
	Move( -127, x );
	armHeight= 0;
}




/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	armHeight = 0;
	SensorValue(drive) = 0;
	StartTask(ArmControl);
	while( true )
	{

		wait1Msec(25);
		motor[driveLFront] = vexRT[Ch3];
		motor[driveLBack] = vexRT[Ch3];

		motor[driveRFront] = vexRT[Ch2];
		motor[driveRBack] = vexRT[Ch2];

		if( vexRT( Btn5U ) )
		{
			//StartTask(armControl);
			motor[liftLT] = 127;
			motor[liftLB] = 127;
			motor[liftRT] = 127;
			motor[liftRB] = 127;
		}
		else if( vexRT( Btn5D ) )
		{
			StopTask(armControl);
			motor[liftLT] = -127;
			motor[liftLB] = -127;
			motor[liftRT] = -127;
			motor[liftRB] = -127;
		}
		else
		{

			motor[liftLT] = 0;
			motor[liftLB] = 0;
			motor[liftRT] = 0;
			motor[liftRB] = 0;
		}

		if( vexRT( Btn6U ) )
		{
			motor[intakeL] = -127;
			motor[intakeR] = -127;
		}
		else if( vexRT( Btn6D ) )
		{
			motor[intakeL] = 127;
			motor[intakeR] = 127;
		}
		else
		{
			motor[intakeL] = 0;
			motor[intakeR] = 0;
		}

		wait1Msec(5);

	}

}
